var Q = require("q");
var request = require("request");
var utils = require('./utils');

var events = require("events");

var containerIds = [];
var emitters = {};

function start(containerId) {
    var deferred = Q.defer();
    console.log("Started " + containerId);
    if (utils.isString(containerId)) {
        if (containerIds.indexOf(containerId) >= 0) {
            deferred.reject("push already running for " + containerId);
        } else {
            containerIds.push(containerId);
            emitters[containerId] = new events.EventEmitter;
            emitters[containerId].firstCon = true;
            deferred.resolve(emitters[containerId]);
            pushloop(containerId);
        }
    } else {
        deferred.reject("containerId has to be a string");
    }

    return deferred.promise;
}

function stop(containerId) {
    var deferred = Q.defer();

    if (utils.isString(containerId)) {
        var idx = containerIds.indexOf(containerId);
        if (idx >= 0) {
            signoff(containerId).then(function () {
                emitters[containerId].emit('disconnect');
                delete emitters[containerId];
                containerIds.splice(idx, 1);
                deferred.resolve(true);
            }).fail(function (reason) {
                deferred.reject(reason);
            });
        } else {
            deferred.reject("No push-service running for " + containerId);
        }
    } else {
        deferred.reject("containerId has to be a string");
    }

    return deferred.promise;
}

function pushloop(containerId) {
    console.log("Pushloop ", containerId);
    connect(containerId).then(function (data) {
        if (emitters[containerId])
            if(emitters[containerId].firstCon){
                emitters[containerId].emit('connect');
                emitters[containerId].firstCon = false;
            }
            emitters[containerId].emit("data", data);
        ack(containerId, data.messageId);
    }).fail(function (reason) {
        console.log("Pushloop reason ", reason);
        if (emitters[containerId])
            emitters[containerId].emit("error", reason);
    }).finally(function () {
        if (emitters[containerId])
            pushloop(containerId);
    });
}

function connect(containerId) {
    var deferred = Q.defer();

    if (utils.isString(containerId)) {
        request({
            url: utils.getAPIUrl("push", containerId),
            method: 'GET',
            qs: {
                apiKey: utils.getAPIkey()
            },
            json: true
        }, function (err, res, data) {
            utils.apiCB(deferred, err, res, data);
        });
    } else {
        deferred.reject("containerId has to be a string.");
    }

    return deferred.promise;
}

function ack(containerId, messageId) {
    var deferred = Q.defer();

    if (utils.isString(containerId) && utils.isString(messageId)) {
        request({
            url: utils.getAPIUrl("push", containerId, "ack", messageId),
            method: 'POST',
            qs: {
                apiKey: utils.getAPIkey()
            },
            json: true
        }, function (err, res, data) {
            utils.apiCB(deferred, err, res, data);
        });
    } else {
        deferred.reject("containerId and messageId has to be a string.")
    }

    return deferred.promise;
}

function result(containerId, messageId, success, message, data) {
    var deferred = Q.defer();

    var error;

    if (!utils.isString(containerId))
        error = "containerId is not a string";
    if (!utils.isString(messageId))
        error = "messageId is not a string";
    if (!utils.isBoolean(success))
        error = "success is not a boolean";
    if (!utils.isString(message) || (message === undefined))
        error = "message is not a string or undefined";
    if (!utils.isObject(data) || (data === undefined))
        error = "data is not an object or undefined";

    if (!error) {
        request({
            url: utils.getAPIUrl("push", containerId, "result", messageId),
            method: 'POST',
            qs: {
                apiKey: utils.getAPIkey()
            },
            json: {
                success: success,
                message: message,
                data: data
            }
        }, function (err, res, data) {
            utils.apiCB(deferred, err, res, data);
        });
    } else {
        deferred.reject(error);
    }
    return deferred.promise;
}

function signoff(containerId) {
    var deferred = Q.defer();

    if (utils.isString(containerId)) {
        request({
            url: utils.getAPIUrl("push", containerId, "signoff"),
            method: 'GET',
            qs: {
                apiKey: utils.getAPIkey()
            },
            json: true
        }, function (err, res, data) {
            utils.apiCB(deferred, err, res, data);
        });
    } else {
        deferred.reject("containerId has to be a string.");
    }

    return deferred.promise;
}

(function ($) {
    $.start = start;
    $.result = result;
    $.stop = stop;
})(exports);